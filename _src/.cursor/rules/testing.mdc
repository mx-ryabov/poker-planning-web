---
globs: *.test.tsx,*test.ts
alwaysApply: false
---

# TESTING RULES FOR THE PROJECT COMPONENTS AND HOOKS

## Rules the AI must follow

-   Use `@/test/utilities` (render, act, within, waitFor, user-event) instead of raw React Testing Library APIs
-   Always take `user` from the returned object of `render(...)` and use it for interactions
-   Always define a dedicated `renderComponent`/`renderHook` helper per test file to pass wrapper and mocks
-   Include an a11y test with `jest-axe`: expect results to `toHaveNoViolations()`
-   If IntersectionObserver is required, import `"@/__mocks__/intersection-observer"` at the top
-   Prefer `vi.useFakeTimers({ shouldAdvanceTime: true })` and restore timers/mocks in `beforeEach/afterEach` where timing is involved
-   Path aliases observed in existing tests must be preserved: `@/test/utilities`, `@/_src/shared/api`, and local `../__mocks__`, `../__tests__/...`
-   Prefer `within(...)` for scoping queries and `data-testid` values consistent with UI components
-   Name the a11y test: "doesn't violate any accessibility rules" (typo-free)
-   Use `renderComponent`/`renderWithStore` helpers; keep them at the bottom of the test file for readability
-   If a tested component uses `useLocalStorageState` hook under the hood then use `__clearStorageCache__TestOnly()` in `beforeEach`.

## Patterns

### Good imports

```typescript
import { test, describe, expect, vi, beforeEach, afterEach } from "vitest";
import { act, render, within, waitFor } from "@/test/utilities";
import { axe } from "jest-axe";
```

### Example: Component test with wrapper and a11y

```typescript
describe("TestComponent", () => {
	test("renders successfully", async () => {
		const { unmount } = renderComponent();
		expect(() => unmount()).not.toThrow();
	});

	test("doesn't violate any accessibility rules", async () => {
		const { container } = renderComponent();
		const results = await axe(container);
		expect(results).toHaveNoViolations();
	});
});
```

### Example: Timers in tests

```typescript
beforeEach(() => {
	vi.useFakeTimers({ shouldAdvanceTime: true });
});

afterEach(() => {
	vi.runOnlyPendingTimers();
	vi.useRealTimers();
	vi.restoreAllMocks();
});
```
