---
globs: *.test.tsx,*.test.ts
alwaysApply: false
---

# Project Testing Patterns

This file contains project-specific testing patterns. For general testing philosophy, see `.cursor/rules/unit-testing.mdc`.

## Required Imports

Always use project utilities instead of raw Testing Library APIs:

```typescript
import { test, describe, expect, vi, beforeEach, afterEach } from "vitest";
import { act, render, within, waitFor } from "@/test/utilities";
import { axe } from "jest-axe";
```

## Render Helper Pattern

Always define a `renderComponent` helper at the **bottom** of each test file:

```typescript
describe("MyComponent", () => {
	test("renders successfully", () => {
		const { unmount } = renderComponent();
		expect(() => unmount()).not.toThrow();
	});

	test("doesn't violate any accessibility rules", async () => {
		const { container } = renderComponent();
		const results = await axe(container);
		expect(results).toHaveNoViolations();
	});
});

// Helper at the bottom of the file
function renderComponent(props: Partial<MyComponentProps> = {}) {
	const defaultProps: MyComponentProps = {
		// default props
	};
	return render(<MyComponent {...defaultProps} {...props} />);
}
```

## Accessibility Testing

Every component MUST have an a11y test:

```typescript
test("doesn't violate any accessibility rules", async () => {
	const { container } = renderComponent();
	const results = await axe(container);
	expect(results).toHaveNoViolations();
});
```

-   Use exact test name: `"doesn't violate any accessibility rules"`
-   Import `axe` from `jest-axe`

## User Interactions

Always take `user` from the render result:

```typescript
test("handles click", async () => {
	const { user } = renderComponent();
	const button = screen.getByRole("button");
	await user.click(button);
	// assertions
});
```

## Scoped Queries

Use `within(...)` for scoping queries to specific containers:

```typescript
const card = screen.getByTestId("user-card");
const name = within(card).getByText("John");
```

## Timer Handling

When tests involve timers:

```typescript
beforeEach(() => {
	vi.useFakeTimers({ shouldAdvanceTime: true });
});

afterEach(() => {
	vi.runOnlyPendingTimers();
	vi.useRealTimers();
	vi.restoreAllMocks();
});
```

## Browser API Mocks

### IntersectionObserver

```typescript
import "@/__mocks__/intersection-observer";
```

### LocalStorage

If component uses `useLocalStorageState`:

```typescript
import { __clearStorageCache__TestOnly } from "@/src/shared/lib";

beforeEach(() => {
	__clearStorageCache__TestOnly();
});
```

## Path Aliases

Use consistent path aliases:

| Alias              | Usage                                 |
| ------------------ | ------------------------------------- |
| `@/test/utilities` | Testing utilities (render, act, etc.) |
| `@/src/shared/`    | Shared layer imports                  |
| `@/__mocks__/`     | Global mocks                          |
| `../__mocks__/`    | Local mocks relative to test          |

## Store Testing (Zustand)

For components with Zustand stores, use `renderWithStore` helper:

```typescript
function renderWithStore(
	props: Partial<Props> = {},
	storeOverrides: Partial<StoreState> = {}
) {
	// Setup store with overrides
	return render(<Component {...props} />);
}
```

## Hook Testing

Use `renderHook` for testing hooks in isolation:

```typescript
import { renderHook, act } from "@/test/utilities";

test("updates state correctly", () => {
	const { result } = renderHook(() => useMyHook());

	act(() => {
		result.current.updateValue("new");
	});

	expect(result.current.value).toBe("new");
});
```
