---
globs: *.test.tsx,*.test.ts
alwaysApply: false
---

# Unit Testing Philosophy

## Core Principles

**Test behavior, not implementation**

-   Focus on what the code does from a user's perspective
-   Test inputs and outputs, not internal state or private methods
-   Use Testing Library principles: query by text, labels, roles

**Gray box approach**

-   Test through public APIs and observable behavior
-   Use implementation knowledge to identify edge cases and critical paths
-   Don't assert on internal state, private methods, or specific function calls

## What to Test

-   Critical functionality (business logic, utility functions, user interactions)
-   Component behavior and user-facing outputs
-   Complex hooks (if reusable or containing significant logic)
-   Error states and edge cases
-   Various data scenarios (valid, invalid, edge cases, empty states)

## Best Practices

**1. AAA Pattern**: Structure tests with Arrange (setup), Act (execute), Assert (verify)

**2. Descriptive Naming**: Describe expected behavior, not implementation

-   ✅ Good: "displays error message when API call fails"
-   ❌ Bad: "calls handleError function"

**3. Test Organization**: Group related tests in `describe` blocks with clear hierarchy

**4. Test Independence**: Each test should run in isolation

**5. Edge Cases**: Always include tests for:

-   Undefined/null values
-   Boundary values
-   Empty arrays/objects
-   Loading and error states

**6. Dependency Mocking**: Mock external dependencies with `vi.mock()`

-   Mock API calls, external services, browser APIs
-   Keep mocks simple and focused
-   Don't over-mock — test your own code

**7. test.each for repetitive tests**: Use `test.each` for multiple scenarios, NOT `forEach` inside a single test

**8. Unimplemented scenarios**: If implementation doesn't handle a scenario, write the test with `.todo()` or `.skip()` and a comment

## Test Structure Template

```typescript
describe("ComponentName or functionName", () => {
	beforeEach(() => {
		// Reset mocks, clear storage, etc.
	});

	describe("when [scenario]", () => {
		it("should [expected behavior]", () => {
			// Arrange
			// Act
			// Assert
		});
	});

	describe("edge cases", () => {
		it("should handle [edge case]", () => {
			// Test edge case
		});
	});
});
```

## Anti-Patterns to Avoid

-   Testing implementation details (internal state, private methods)
-   Using CSS selectors when accessible queries are available
-   Writing tests that pass when they should fail
-   100% coverage as a goal rather than meaningful tests
-   Duplicate test logic (use `test.each` or helper functions)
-   Overly complex test setup that obscures what's being tested

## Project-Specific Rules

For project-specific testing patterns (imports, helpers, a11y), see:
`src/.cursor/rules/testing.mdc`
